#!/usr/bin/env python3
import os
import sys
import pprint
from pathlib import Path
from collections import OrderedDict

import yaml
import click


# Global constants
DEFAULT_CONFIG_PATH=os.path.expanduser("~/.anssh.yml")

# Helper functions
## Config parsing
def get_config(configfile=None):
    if configfile is None:
        configfile = open(DEFAULT_CONFIG_PATH, 'r')
    config = yaml.safe_load(configfile.read())
    if config is None:
        config = {}
    return config

def parse_hosts_node(node):
    parsed_nodes = list()
    for node_item in node.items():
        if node_item[0] == 'children':
            if node_item[1] is not None:
                for subnode in node_item[1].items():
                    parsed_nodes = parsed_nodes + parse_hosts_node(subnode[1])
        if node_item[0] == 'hosts':
            if node_item[1] is not None:
                for subnode in node_item[1].items():
                    temp_node = dict()
                    temp_node['name'] = subnode[0]
                    temp_node['host'] = subnode[1].get('ansible_host', temp_node['name'])
                    temp_node['port'] = subnode[1].get('ansible_port', None)
                    temp_node['user'] = subnode[1].get('ansible_user', None)
                    temp_node['ssh_key'] = subnode[1].get('ansible_ssh_private_key_file', None)
                    temp_node['options'] = subnode[1].get('ansible_ssh_common_args', None)
                    if temp_node['ssh_key'] is not None:
                        temp_node['ssh_key'] = os.path.expanduser(temp_node['ssh_key'])
                    parsed_nodes.append(temp_node)
    return parsed_nodes

def parse_hosts(hosts_file_dict):
    with open(hosts_file_dict['hosts_path']) as fil:
        hosts_file_data = yaml.safe_load(fil.read())
    parsed_data = parse_hosts_node(hosts_file_data['all'])
    # Merge with other data in hosts_file_dict
    for data in parsed_data:
        data['user'] = data['user'] if data['user'] is not None else hosts_file_dict['user']
        data['ssh_key'] = data['ssh_key'] if data['ssh_key'] is not None else hosts_file_dict['ssh_key']
        data['options'] = data['options'] if data['options'] is not None else hosts_file_dict['options']
        data['namespace'] = hosts_file_dict['namespace']
        data['client'] = hosts_file_dict['client']
    return parsed_data

def generate_hosts(config):
    hosts = list()
    hosts_files = list()

    # Get default params from config if it present
    defaults = config.get('default', dict())

    # Per namespace, generate list of hosts files
    for namespace in config.get('namespaces', []):
        namespace_name = namespace['name']
        namespace_user = namespace.get('user', defaults.get('user', None)) # None will use system default
        namespace_ssh_key = namespace.get('ssh_key', defaults.get('ssh_key', None)) # Same
        namespace_options = namespace.get('options', defaults.get('options', None)) # Same
        if namespace_ssh_key is not None:
            namespace_ssh_key = os.path.expanduser(namespace_ssh_key)

        # Get list of hosts files from namespace `clients` key
        for client in namespace.get('clients', list()):
            client_name = client['name']
            client_user = client.get('user', namespace_user)
            client_ssh_key = client.get('ssh_key', namespace_ssh_key)
            client_options = client.get('options', namespace_options)
            if client_ssh_key is not None:
                client_ssh_key = os.path.expanduser(client_ssh_key)
            client_hosts_path = client['hosts_path']

            # Add hosts_files config
            hosts_files.append({
                'user': client_user,
                'ssh_key': client_ssh_key,
                'options': client_options,
                'hosts_path': os.path.expanduser(client_hosts_path),
                'client': client_name,
                'namespace': namespace_name,
                })

        # Get list of hosts files from autodetect
        for auto_clients in namespace.get('autodetect_clients', list()):
            auto_clients_user = auto_clients.get('user', namespace_user)
            auto_clients_ssh_key = client.get('ssh_key', namespace_ssh_key)
            auto_clients_options = client.get('options', namespace_options)
            if auto_clients_ssh_key is not None:
                auto_clients_ssh_key = os.path.expanduser(auto_clients_ssh_key)

            auto_clients_root = auto_clients['inventories_path']
            auto_clients_hosts_filename = auto_clients['hosts_filename']

            # Get list of users in auto_clients_root by the name of dirs
            auto_clients_subdirs = next(os.walk(os.path.expanduser(auto_clients_root)))[1]
            for client_name in auto_clients_subdirs:
                client_hosts_path = os.path.join(auto_clients_root, client_name, auto_clients_hosts_filename)

                hosts_files.append({
                    'user': auto_clients_user,
                    'ssh_key': auto_clients_ssh_key,
                    'options': auto_clients_options,
                    'hosts_path': os.path.expanduser(client_hosts_path),
                    'client': client_name,
                    'namespace': namespace_name,
                    })

        # Generate hosts based on hosts_files
        for hosts_file_dict in hosts_files:
            hosts = hosts + parse_hosts(hosts_file_dict)

    return hosts

def hosts_array_to_dict(hosts_data):
    def merge(source, destination):
        """
        Taken from https://stackoverflow.com/questions/20656135/python-deep-merge-dictionary-data

        run me with nosetests --with-doctest file.py

        >>> a = { 'first' : { 'all_rows' : { 'pass' : 'dog', 'number' : '1' } } }
        >>> b = { 'first' : { 'all_rows' : { 'fail' : 'cat', 'number' : '5' } } }
        >>> merge(b, a) == { 'first' : { 'all_rows' : { 'pass' : 'dog', 'fail' : 'cat', 'number' : '5' } } }
        True
        """
        for key, value in source.items():
            if isinstance(value, OrderedDict):
                # get node or create one
                node = destination.setdefault(key, OrderedDict())
                merge(value, node)
            else:
                destination[key] = value

        return destination

    hosts_dict = OrderedDict()

    for host in hosts_data:
        tmp_host = host.copy()
        tmp_host.pop('client', None)
        tmp_host.pop('namespace', None)
        tmp_host.pop('name', None)
        cur_host =OrderedDict({host['namespace']: OrderedDict({host['client']: OrderedDict({host['name']: tmp_host}) }) })
        hosts_dict = merge(hosts_dict.copy(), cur_host)

    return hosts_dict

## Connection string generation
def generate_ssh_command(host_data):
    args = ['ssh']
    args = args + ([] if host_data['user'] is None else ['-l', host_data['user']])
    args = args + ([] if host_data['ssh_key'] is None else ['-i', host_data['ssh_key']])
    args = args + ([] if host_data['options'] is None else [host_data['options']])
    args = args + ([] if host_data['port'] is None else ['-p', str(host_data['port'])])
    args = args + [host_data['host']]
    return ' '.join(args)


## Autocompletion functions
# XXX usage of dynamic ctx is pretty much broken at the moment, so only default config will will work https://github.com/pallets/click/issues/942
def auto_get_namespaces(ctx, args, incomplete):
    if ctx.obj is None:
        config = get_config()
    else:
        config = ctx.obj['config']
    namespaces_available = list(
            hosts_array_to_dict(
                generate_hosts(
                    config
                    )
                ).keys()
            )
    namespaces = list()
    if len(incomplete) > 0:
        for namespace in  namespaces_available:
            if namespace.startswith(incomplete):
                namespaces.append(namespace)
    else:
        namespaces = namespaces_available

    return namespaces

def auto_get_clients(ctx, args, incomplete):
    if ctx.obj is None:
        config = get_config()
    else:
        config = ctx.obj['config']

    namespace = args[1]

    clients_available = list(
            hosts_array_to_dict(
                generate_hosts(
                    config
                    )
                )[namespace].keys()
            )

    clients = list()
    if len(incomplete) > 0:
        for client in  clients_available:
            if client.startswith(incomplete):
                clients.append(client)
    else:
        clients = clients_available

    return clients

def auto_get_hosts(ctx, args, incomplete):
    if ctx.obj is None:
        config = get_config()
    else:
        config = ctx.obj['config']

    namespace = args[1]

    client = args[2]

    hosts_available = list(
            hosts_array_to_dict(
                generate_hosts(
                    config
                    )
                )[namespace][client].keys()
            )

    hosts = list()
    if len(incomplete) > 0:
        for host in  hosts_available:
            if host.startswith(incomplete):
                hosts.append(host)
    else:
        hosts = hosts_available

    return hosts


# Click grouping
@click.group()
@click.pass_context
@click.option('--configfile', envvar='ANSSH_CONFIGFILE', default=DEFAULT_CONFIG_PATH, help='Path to config file', type=click.File('r'))
def cli(ctx, configfile):
    ctx.obj['config'] = get_config(configfile)

# Click commands
@cli.command()
@click.pass_context
def complete(ctx):
    script_path = os.path.realpath(__file__)

    click.echo("To add autocompletion, add this lines to ~/.bashrc:")
    click.echo("source <(_{}_COMPLETE=source {})".format(os.path.basename(__file__).upper(), script_path))

@cli.command()
@click.pass_context
def test_config(ctx):
    click.echo('Current list of hosts files based on config:')
    hosts = generate_hosts(ctx.obj['config'])
    pprint.pprint(hosts)
    click.echo('In dict format:')
    pprint.pprint(hosts_array_to_dict(hosts))

@cli.command()
@click.pass_context
@click.argument('namespace', type=click.STRING, autocompletion=auto_get_namespaces)
def generate_apptmux_sessions_file(ctx, namespace):
    hosts_dict = hosts_array_to_dict(generate_hosts(ctx.obj['config']))

    if namespace in hosts_dict:

        for client_name in hosts_dict[namespace].keys():
            click.echo(client_name)

    else:
        click.echo("Namespace {} does not exist in config file".format(namespace))
        click.echo()
        click.echo("Available namespaces:")
        click.echo(', '.join(list(hosts_dict.keys())))
        sys.exit(1)

@cli.command()
@click.pass_context
@click.argument('namespace', type=click.STRING, autocompletion=auto_get_namespaces)
@click.argument('client', type=click.STRING, autocompletion=auto_get_clients)
def generate_apptmux_sessions_list(ctx, namespace, client):
    hosts_dict = hosts_array_to_dict(generate_hosts(ctx.obj['config']))

    # Example - tmux new-window -n 'windy.database' -t Windy:1 'ssh -i ~/.ssh/my -p 22 ddunaev@5.9.6.115'
    if namespace in hosts_dict:

        if client in hosts_dict[namespace]:

                for host_name, host in hosts_dict[namespace][client].items():

                    host_number = list(hosts_dict[namespace][client].values()).index(host) + 1
                    ssh_command = generate_ssh_command(host)
                    click.echo("tmux new-window -n '{}' -t {}:{} '{}'".format(
                        host_name,
                        client,
                        host_number,
                        ssh_command,
                        )
                    )

        else:
            click.echo("Client {} in namepace {} does not exist in config file".format(client, namespace))
            click.echo()
            click.echo("Available clients in namespace {}:".format(namespace))
            click.echo(', '.join(list(hosts_dict[namespace].keys())))
            sys.exit(1)
    else:
        click.echo("Namespace {} does not exist in config file".format(namespace))
        click.echo()
        click.echo("Available namespaces:")
        click.echo(', '.join(list(hosts_dict.keys())))
        sys.exit(1)

@cli.command()
@click.pass_context
@click.argument('namespace', type=click.STRING, autocompletion=auto_get_namespaces)
@click.argument('client', type=click.STRING, autocompletion=auto_get_clients)
@click.argument('host', type=click.STRING, autocompletion=auto_get_hosts)
def connect(ctx, namespace, client, host):
    command = generate_ssh_command(
            hosts_array_to_dict(
                generate_hosts(
                    ctx.obj['config']
                    )
                )[namespace][client][host]
            )
    click.echo(command)
    os.system(command)

if __name__ == "__main__":
    cli(obj={})
